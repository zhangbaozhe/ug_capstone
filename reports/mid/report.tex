\documentclass[letterpaper,journal,twoside]{IEEEtran}
\usepackage{amsmath,amsfonts}
\usepackage{array}
\usepackage{textcomp}
\usepackage{stfloats}
\usepackage{url}
\usepackage{verbatim}
\usepackage{graphicx}
\usepackage{cite}
\usepackage{xcolor}
\usepackage{subcaption}
\usepackage{mathtools}  
\usepackage{amssymb}
\usepackage{tabulary}
\usepackage{booktabs}
\usepackage[ruled,linesnumbered]{algorithm2e}
\usepackage{algorithmic}
\usepackage{hyperref}
\usepackage{setspace}

% usepackage from 
\usepackage{adjustbox}
\usepackage{physics}
\usepackage{amsmath}
\usepackage{tikz}
\usepackage{mathdots}
\usepackage{yhmath}
\usepackage{cancel}
\usepackage{color}
\usepackage{siunitx}
\usepackage{array}
\usepackage{multirow}
\usepackage{amssymb}
\usepackage{gensymb}
\usepackage{tabularx}
\usepackage{extarrows}
\usepackage{booktabs}
\usetikzlibrary{fadings}
\usetikzlibrary{patterns}
\usetikzlibrary{shadows.blur}
\usetikzlibrary{shapes}

\newcommand{\B}[1]{\boldsymbol{#1}}
\newcommand{\TB}[1]{\textbf{#1}}
\newcommand{\etal}{\textit{et al.}}

\begin{document}

\title{Multi-drone Motion Planning \& Control in Dynamic Environment based on Deep Reinforcement Learning}

\author{
  \IEEEauthorblockN{
    Baozhe Zhang\IEEEauthorrefmark{1}
  }
}

\maketitle

\begingroup
\renewcommand\thefootnote{\IEEEauthorrefmark{1}}
\footnotetext{School of Science and Engineering, The Chinese University of Hong Kong, Shenzhen, China. (Email: \texttt{\{baozhezhang\}@link.cuhk.edu.cn})}
\endgroup

% The paper headers
\markboth{ERG4901: Capstone Project -- Mid-Term Report}%
%{Shell \MakeLowercase{\textit{et al.}}: A Sample Article Using IEEEtran.cls for IEEE Journals}
{Zhang: Multi-drone Motion Planning \& Control}

% \IEEEpubid{\copyright~2023 Baozhe Zhang}
% Remember, if you use this you must call \IEEEpubidadjcol in the second
% column for its text to clear the IEEEpubid mark.


\begin{abstract}
TODO
\end{abstract}

\begin{IEEEkeywords}
  TODO
\end{IEEEkeywords}

\section{Introduction}
\IEEEPARstart{R}{ecently}, micro aerial vehicles (MAVs) or 
drones have been widely used in cinematography, search and 
rescue, inspection, and other tasks that require 
high-mobility or are difficult and unsafe for humans to 
operate. 
The planning and control system for plays a great role for 
unmanned aerial vehicles (UAVs) to perform the 
above mentioned tasks autonomously.

\section{Related Work}

In this section, we will investigate both traditional 
and RL-based methods for planning and control in the 
literature, with more focus on the aerial systems 
such as drones or quadrotors.
Traditional planning and control frameworks are decoupled.
% Path planning module serves as a frontend to find a geometric collision-free path in the given map, and motion planning module, based on the found path, finds the suitable dynamic-feasible motions for the robots. 
The path-(motion-)planning module serves as a guide system 
for the low-level controller driving the robot to move. 
This module needs to generate a geometrically 
collision-free and possibly kinodynamic feasible trajectory 
(or motion setpoints) for the low-level controller.
Then the low-level control module can use these motion 
setpoints to control the actuators on the robots to move.
Recent RL-based methods try to combine these two modules 
into a coupled system from repeated learning. 
The robots learn to navigate itself by trials and learning 
from the environments.
These trials are mostly conducted in simulations, 
where high-fidelity physics engines are required. 
By utilizing certain (deep) RL training methods, 
the trained models (e.g., neural networks) can be deployed 
on real robots for autonomous navigation in various static 
or dynamic environments.

\subsection{Map Representation and Configuration Space}
TODO: Occupancy, grid, ESDF, TSDF, topological

kd-tree, octo, 





\subsection{Traditional Planning and Control Methods}


\input{../figures/planning_concept.tex}
In general, path-planning algorithms for robot navigation 
can be divided into two major categories: 
global and local methods.  
Global methods focus on finding collision-free paths from 
the current robot position to a global goal position mostly 
in static scenes, while local methods tend to reactively 
avoid both static and dynamic obstacles. 
In order to generate smooth trajectories for robots to 
follow, based on the discrete planned waypoints, the 
trajectory optimization module is usually added in the 
whole pipeline. 
Usually in the literature, the path-finding module 
is called the frontend and the 
trajectory-optimization module is called the backend. 
A typical traditional planning pipeline can be 
found in Fig.~\ref{fig:concept}.

\subsubsection{Path finding (frontend)}

In the path-finding stage of the global planning, 
the methods can be categorized 
from three major directions: \TB{search-based}, 
\TB{sample-based}, and \TB{kinodynamic} methods. 


% \input{../algorithms/a_star.tex}
\TB{Search-based} algorithms such as depth-first 
search (DFS), breadth-first search (BFS), 
Dijkstra \cite{wang2011application}, and 
A* \cite{hart1968formal}, use path-search methods 
with (or without) certain pre-defined heuristics to find 
geometrically feasible paths on given grid maps. 
A key assumption for these methods to perform path-finding 
is the map is given, which can be difficult to be obtained 
in certain situations. 
Though these search-based methods can perform well, they 
can have longer search time when the space scales.
% Alg.~\ref{alg:a_star} shows the A* path-planning algorithm which returns the shortest path from the source node to the target node. 
\TB{Sample-based} methods such as rapidly exploring random 
tree (RRT), probabilistic roadmap (PRM), and their 
variants use sampling in the configuration space (C-Space) 
to crate collision-free paths \cite{lavalle2001rapidly,
karaman2011sampling,kavraki1996probabilistic}. 
The general form of RRT algorithm can be found in 
Alg.~\ref{alg:rrt}.
\input{../algorithms/rrt.tex}
However, the tree nodes in these methods need to cover the 
whole C-Space which may suffer from heavy computational 
loads especially when the space is large.  

Both search- and sample-based methods can generate 
geometrically collision-free paths but possibly jerky or 
violating the underlying robots' dynamics.
For example, most ground vehicles are not 
holonomic, i.e., they cannot move freely in all directions 
in 2D space, where their motions are governed by their 
mechanical and motion constraints (e.g., velocities and 
accelerations).
In order to obey both the kinematic and dynamic 
constraints for specific
robot platforms and reduce the stress of the backend 
optimization part, \TB{kinodynamic} methods are introduced
in the literature. 
Donald \etal \cite{donald1993kinodynamic} first proposed 
the term \TB{kinodynamic} motion planning in the literature.
The authors proposed he first provably good approximation 
algorithm about the motion planning for a point-mass model 
in 2D and 3D environments with polyhedral obstacles.

Other less common method such as model predictive 
control (MPC) added with obstacle constraints or with 
additional environment-related 
terms \cite{park2009obstacle,ji2016path}  can also be 
used to generate collision-free paths, which is based on 
quadratic-programming (QP) optimization. 
However, MPC-related methods need to tradeoff among the 
length of the time horizon, the computational loads, and 
optimality. Short time horizon often leads the problem to 
sub-optimal solutions.




\subsubsection{Trajectory generation/optimization (backend)}
To generate both smooth and kinodynamic feasible 
trajectories, trajectory optimization is included to 
solve the problem.

\subsubsection{Local methods}
Most global methods perform well in static environments, 
but poorly in dynamic environments. 
Local path-planning methods can be employed to handle 
this problem. 
An early local obstacle-avoidance method is artificial 
potential field (APF) \cite{warren1989global}.
APF formulates the potentials on a given path as the 
inside and outside ones, and pushes the path from 
high-potential to low-potential region by finding the 
lowest potential value. 
If the waypoints on the path across the 
obstacle (in the obstacle), the potential is formulated as 
\begin{equation}
\label{eq:APF_in}
U_{\text{in}} = 
U_{\text{max}}(1 - \frac{R_{\text{in}}}{R_{\text{max}}}) + 
U_{\text{offset}}
\end{equation}
where $U_{\text{max}}$ is the max potential, 
$R_{\text{in}}$ is the distance to the centroid of the 
obstacle, $R_{\text{max}}$ is the max radius of the 
obstacle, and $U_{\text{offset}}$ is the extra 
potential penalty.
The outside potential is formulated as 
\begin{equation}
\label{eq:APF_out}
U_{\text{out}} = 
\frac{1}{2}U_{\text{offset}}(1+ \frac{1}{1+R_\text{out}})
\end{equation}
where $R_{\text{out}}$ is the distance outside the obstacle.
APF can be used for quadrotor path-planning \cite{chen2016uav}.
However, when multiple obstacles presented, APF can suffer 
from the problem of local minimum \cite{koren1991potential}.

VO ...

\subsubsection{Control}
Control.

\subsection{RL-based Planning and Control Methods}

\subsection{Multi-robot Planning and Control}

\section{Problem Formulation}

\bibliographystyle{IEEEtran}
\bibliography{report}


\end{document}


